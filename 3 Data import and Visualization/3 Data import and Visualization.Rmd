---
title: "Level3 - データインポートと可視化"
output: 
 html_notebook:
   css: font-style.css
---

前回までで実験データの可視化の準備は整いました。  

**今回の主な内容は外部データを読み込んで、可視化に適した構造のデータフレーム - 1行1レコードのデータフレームを作成することです**。ただし、これだけ分かれば外部データの可視化はできるものの、実験から得られた同じ形式のデータファイルがたくさんあって、そのすべてを可視化したいとき、1個ずつ処理するコードを書くのは大変です。コピペすればファイルが数個くらいならそれでもいいですが、もっとスマートに、高速にやりたいものです。  

というわけで、複数の同形式のファイルがあるときの（ちょっとした）自動化も取り上げます。  

* 1個のデータファイルからデータフレームを作成する方法  
* 複数のデータファイルからデータフレームを作成する方法  

今回もライブラリを使いますので、以下のチャンクを実行しておいてください。  

```{r results = 'hide'}
library(tidyverse)
```

# 1個のデータファイルからデータフレームを作成する方法  

## データファイルのインポート  

今回は時間 vs 加速度のデータを例題として使います。Rstudio のプロジェクトフォルダの直下に、Github からダウンロードした sample というフォルダをコピーしておいてください。フォルダの中にはテキストファイルが2つ入っていますが、どちらでもいいのでテキストエディタで開いてどんなファイルなのかざっくり把握してください。  

それでは例のごとく、まずはやってみましょう。  

```{r}
# データのインポート
read_csv("./sample/CH1_TS.txt",    # ファイル名をダブルクォーテーションで囲って指定
         skip = 16,                # 冒頭 16 行はインポートしない
         col_names  = F)           # 各列の名前はなし
```

インポートできました。コメントでなんとなく分かると思いますが、少し詳しく説明すると...  

* read_csv：
  csv ファイルをインポートする関数。拡張子が csv でなくても、内容がカンマ区切りならインポートできる。  

* "./sample/CH1_TS.txt"：  
  インポートするファイルの場所と名前を指定（下記に補足）。

* skip = 16：  
  今回指定したファイル CH1_TS.txt は、冒頭16行目までヘッダー情報で、必要ありません。計測システムによってこういったヘッダーが追加されますので、事前に行数を確認しておきます。  
  
* col_names = F：  
  今回のファイルには列が 2 つありますが、それぞれの列には名前がついていません（正確にはヘッダー情報に示されてはいるのですが、read_csv では認識できません）。そのため、F（False）を指定して列名がない、という指定をしています。  

> インポートするファイルと場所の指定
./sample/ までがファイルの場所で、ピリオド "." は「現在の作業フォルダ」という意味です。したがって、./sample/ は、"現在の作業フォルダにある sample というフォルダの中身" という指定をしています。ちなみに、ピリオド 2 つ ".." は「現在の作業フォルダの 1 つ上のフォルダ」という意味。二重で指定すると "../../" 「上の上のフォルダ」、となります（3重以上も指定可能）。この指定の仕方は R に限らず、その他の言語でも共通しています。なお、「現在の作業フォルダ」は、プロジェクトを作成するときに指定したフォルダ。getwd() で現在のフォルダを確認することができる。

以上の設定で読み込みを実行すると、R が自動的に読み込むデータの型（今回は double 型の変数と認識）を認識し、さらに列の数も認識し、無事 2 列分を読み込みました。  

上の実行例はとりあえず読み込んだだけなので、そのままでは使えません。**読み込んだ結果を適当な名前のオブジェクトに代入しておけば、後で使えます**。read_csv に限らず R の関数は 1 行で実行しても良いので下の例では書き直しました。  

```{r}
ch1 <- read_csv("./sample/CH1_TS.txt", skip = 16, col_names  = F) # インポートしたデータを ch1 に格納
```

データの中身を見ておきましょう。  

```{r}
ch1
```

読み込んだときは、データの型やデータの数（行数や列数）などを確認する癖をつけておくと後々のトラブルを防げます。  

```{r}
class(ch1)
```

```{r}
str(ch1)
```

今回はきちんと、クラスはデータフレーム、各列の型は double、列数 2、行数 4,096 で意図した読み込みができたと判断できました。  

>行数も R が自動で認識し、最後の行までインポートされます。  

ここでひとつ気になるのが列の名前です。str の出力などから、1列目の列名は X1, 2列目の列名は X2 となっていますが、これは読み込んだ順番に 「X＋数字」をつけていくようになっています。これだと何の変数かわかりづらいので、普通は名前を変えます。  

```{r}
# 列の名前を変える  
colnames(ch1) <- c("Time", "Acceleration")
```

```{r}
ch1
```

列名が変わりました。X1 と X2 の両方を同時に変更したので、c() によりベクトルで名前を指定します。  

ところで、列名がある場合のデータファイルはどんな感じなのか、同じく sample フォルダの CH1_TS_Colnames.txt を開いてみてください。17行目に列名の行が入っています。このファイルを読み込むときは次のようになります。    

```{r}
ch1 <- read_csv("./sample/CH1_TS_Colnames.txt", skip = 16, col_names = T)  # col_names = T に変更
```

```{r}
ch1
```

この場合はファイルに記載の列名が読み込まれますので、colnames() で列名を変更する必要がありません。  

このファイルに関しては、インポートはこれで終了です。列数が 2 つしかなく、1行1レコードになっているのでこれ以上のデータ操作も必要ありません。せっかくなのでグラフを描いてみてください。  

ここではもっとも頻度が高いと思われるカンマ区切りデータのインポート方法でしたが、ほぼ同じ手順で別の形式のデータもインポートできます。  

* read_tsv：タブ区切りのファイルをインポート  
* read_delim：区切り文字を指定してインポート（汎用的だが、インポート動作がのろい）  

skip や col_names の指定方法は同じです。場合に応じて使い分けましょう。  

## データ型の修正  

double 型のデータの場合はここまでやった通り、インポートであまり問題が起きません。しかし、int 型（整数型）では問題が起きることがあります。これは目的によるのですが、その整数を連続的な数値として扱いたい場合は良いのですが、**ファクタ factor 型や文字列型として扱いたい場合は後処理が必要になります**。  

例えば、1, 3, 4, 7 という数値があったとき、これが点数（大きさに意味がある）なのか、アンケートでの水準の値（大きさには意味がなく、選択肢の区別として意味がある）なのか、ぱっと見では判別できません。R はそんな判断はできないので、インポートするときは整数型でインポートします。**この差は可視化をするときにも影響があります**。以下に例を示しますが、データフレームの作成の過程はわからなくてもOKです。  

```{r}
# 例の作成
x <- seq(0, 2, length.out = 11)     # 0〜2まで、11個の等間隔の数値ベクトルを作成
test.df <- tibble(
  x = x,
  y1 = x,
  y2 = x^2,
  y3 = x^3
)
test.df <- test.df %>%
  gather(y1:y3, key = y, value = val) %>%
  select(-y)
test.df$y <- rep(1:3, each = 11)   # y に識別番号をつける
```

```{r}
test.df
```

このデータフレームは、x が x 軸の値、val が各関数の値、y が関数の識別番号、という想定です。y の型は int 型になっています。つまり、データの大きさに意味がある、という風に認識されています。このデータフレームで 3 つの関数のグラフを重ね書きして、色で区別したい、としましょう。  

```{r}
# グラフ描画
ggplot(test.df, aes(x, val, group = y, col = y)) +
  geom_line()
```

あれ？なんか色がグラデーションになっててわかりづらい...　と思いませんか？こういうグラフが描きたいことももちろんありますが、もっとはっきりグラフの一本一本の色を区別して欲しい、というときはデータに修正が必要です。その修正が、y のデータ型をファクタ型または文字列型に変えてしまうことです。  

```{r}
# 型の変更  
test.df$y_fct <- factor(test.df$y)        # ファクタ型にする場合
test.df$y_chr <- as.character(test.df$y)  # 文字型にする場合
test.df
```

本当は y の列はもう不要なので上書きしても良いのですが、今回は変化に着目しているので残したまま列を追加しました。y_fct はファクタ型（fct）、y_chr は文字型（chr）になっています。見かけ上は同じですが、内部的な型が異なります。これで再度可視化してみましょう。  

```{r}
# グラフ描画 - ファクタ型で色付け
ggplot(test.df, aes(x, val, col = y_fct)) +
  geom_line()
```

```{r}
# グラフ描画 - 文字型で色付け
ggplot(test.df, aes(x, val, col = y_chr)) +
  geom_line()
```

色づけの仕方が変わりました。こっちの方が意図した可視化だ！という場合はこうしましょう。  

**ひとつ注意点は、今回はファクタ型も文字型も同じグラフになりましたが、両者は違いがあることです。それは順序があるか。ファクタ型は順序がありますが、文字型はありません**。今回はたまたまファクタ型の順序と文字型の表示される順序が一致しただけ、ということになります。  

ファクタ型はデフォルトで、作成するときに指定したベクトルの「要素の順」に順序をつけます。上の例におけるファクタ型への型変更では、test.df の　y の列を factor() で指定しました。この中身は    

```{r }
test.df$y
```

となっていて、1,2,3 の順に登場します。この順番で順序付けされたということです。これは実行後に確認できます。  

```{r}
test.df$y_fct
```

"Levels:" となっているところが順序を示し、左の方が上位に当たります。  

factor() では、引数 levels で順序を明示的に指定することができるので、順序を変えることでグラフの色付けも変えられます。

```{r}
test.df$y_fct <- factor(test.df$y_fct, levels = c(3, 2, 1))
```

```{r}
# グラフ描画 - ファクタ型で色付け
ggplot(test.df, aes(x, val, col = y_fct)) +
  geom_line()
```

色付けが逆順になりました。levels での指定により、もちろん他のパターンも可能です。  

型の変更は、read_csv でインポートしたときに意図しない型で読み込まれた時に行うようにしましょう。  


# 複数のデータファイルからデータフレームを作成する方法  

1個だけのファイルなら以上の内容で事足りることがほとんどですが、実務では多くの場合、データファイルは大量です。これを1つずつやるのは億劫だし、同じ処理をするのを繰り返すのは時間がかかります。そこで複数ファイルを一括でやってしまおう、というのがここでの目的です。  

これを実行するにはプログラミングの基礎の他、小技をいろいろ知らなければなりません。しかし処理の流れはそんなに難しくはありません。要は、次のことをやるだけです。  

<big><font color = "blue">

1. 複数あるファイルのファイル名を取得する：read_csv で指定するファイル名に使う。またデータの区別に使える(
後述）。
    
2. ファイルの数を取得する：インポートを何回やればいいかわかる  

3. インポートするデータの入れ物を用意する：空のリストを作成する  

4. ファイルの数だけデータをインポートする：繰り返し処理によりデータを連続してインポートする   

5. インポートしたデータを扱いやすいデータフレームにする：gather や mutate などを駆使して可視化に適したデータフレームを作る  

6. リストをデータフレームに変換する：bind_rows  

7. 可視化する  

</font></big>

なお、上の手順に入る前に、読み込むファイルの構造を把握して skip する行数や列名の有無、1つのファイルに含まれる 列数や行数などは確認しておきましょう。 

今回は sample2 というフォルダ内の 18 個のファイルをインポートします。各ファイルは、これまでとほぼ同じ形式のファイルですが、内容が少し違います（1 列目が振動数、2 列目が周波数応答関数の大きさ）。気になる人はファイルをテキストエディタなどで開いて中身を確認してください。  

この先の作業の見通しを良くするために、全体のコードを一度示しておきます。

```{r echo=TRUE, message=FALSE, results='hide'}
# 全作業コード（可視化除く）

# 1 複数あるファイル名を取得
fname <- paste0("./sample2/", list.files("./sample2", pattern = ".txt"))

# 2 ファイルの数を取得
nfile <- length(fname)

# 3 インポートするデータの入れ物：空のリストを作成する
fdata <- vector("list", nfile)

# 4 ファイルの数だけデータをインポートする
# 5 データを扱いやすいデータフレームにする
for(i in 1:nfile){
  fdata[[i]] <- read_csv(fname[i], skip = 19, col_names = F)
  colnames(fdata[[i]]) <- c("freq", "Mag")  # 列に名前をつける
  fdata[[i]]$file <- i                      # ファイル番号を変数として追加（mutate でも良い）
}

# 6 リストをデータフレームに変換する
fdata <- bind_rows(fdata)

# 追加
fdata$file <- factor(fdata$file)   # ファイル番号をファクタ型に変更
```

以下、1つずつ説明していきます。  

## 1. 複数あるファイルのファイル名を取得する  


これは R の関数 list.files() で取得できます。  

```{r}
list.files()
```

何も引数を指定しないと現在の作業フォルダ内のすべてのファイルやフォルダを表示しますが、現実的にはインポートするデータはあるフォルダにまとめて保存されていて、拡張子も同じであることが多いでしょう。したがって、リストするファイルの保存フォルダと拡張子を指定します。

```{r}
list.files("./sample2", pattern = ".txt")
```

>指定したフォルダのさらに下の階層のファイルまでリストアップするときは、list.files の引数に recursive = TRUE を追加します。  

ファイル名が文字列型ベクトルとして出力されていることがわかりますが、まだインポートに適したファイル名になっていません。というのは、read_csv の説明を思い出して欲しいのですが、ファイルがどこにあるか、も重要でした。上の出力にはまだ "どこに" という指定が入っていません。そこで次のようにします。  

```{r}
paste0("./sample2/", list.files("./sample2", pattern = ".txt"))
```

paste0() は文字列をつなげる関数で、上の例だと "./sample2/" と list.files() の出力をつなげています。その結果、"どこに" の情報が追加されたベクトルが得られました。これを後で利用できるように変数に格納しておきましょう。　　

```{r}
fname <- paste0("./sample2/", list.files("./sample2", pattern = ".txt"))
fname
```

なお、今回の例題データは無味乾燥ですが、ファイル名にどんな条件で取られたデータなのか識別するラベルをつけていることも多いと思われます。そのような場合、ここで作成したファイル名のベクトルからそれらのラベルを取得して、後に可視化する際に用いることが可能です。具体的には文字列処理をすることになりますが、脇道に逸れるのでまたの機会に。  

## 2. ファイルの数を取得する  

1 で作成した変数 fname の長さを取得すれば良いので、次の 1 行を実行すれば完了です。  

```{r}
nfile <- length(fname)   # fname ベクトルの長さを nfile に格納
nfile
```

## 3. インポートするデータの入れ物を用意する  

これからデータを連続的にインポートしていくのですが、最終的にはすべてのファイルのデータをひとつのデータフレームで扱えるようにします。そのためには、まず各ファイルのデータを個別にインポートして、それらを区別しつつどこかに一時的に格納しておくと効率が良いです。その一時的な格納場所をリストで作成しておきます。  

リストは"Level 2 - データフレームを知る”で触れましたが、データフレームのようにサイズがあります。今回はファイルの数だけのサイズがあればいいので、次のようにして作成します。  

```{r}
# 空のリストを作成する
fdata <- vector("list", nfile)    # サイズが nfile の空のリストを作成し、fdata に格納する
fdata
```

作成したリスト fdata は、実行して分かるように [[1]]〜[[18]] までの大きさを持ちますが、中身は何も入ってないのですべて NULL になっています。これらの入れ物に各ファイルのデータを格納していくことになります。  

## 4. ファイルの数だけデータをインポートする & 5. インポートしたデータを扱いやすいデータフレームにする  

連続してインポートする前に、リストにどうやってデータを格納するかと言うことを先に説明します。1つ目のファイルをリストに格納してみまましょう。

> skip の数や列名の有無は事前にファイルを開いて確認してあります。  

```{r}
fdata[[1]] <- read_csv(fname[1], skip = 19, col_names = F)
colnames(fdata[[1]]) <- c("freq", "Mag")    # 列に名前をつける
fdata[[1]]$file <- 1                        # ファイル番号を変数として追加（mutate でも良い）
fdata[[1]]
```

fdata の 1 番目 fdata[[1]] に、fname の 1 番目のファイル fname[[1]] をインポートしています。これは今回の前半でファイルを 1 個だけインポートするのと同じ操作ですね。  

また列名も変更し、さらに新しい変数 "file" も、ファイルを識別するために追加しています。ただしここでは数値型で、後でファクタ型に変更します。  


連続してインポートするには、上の fdata[[1]] とか、fname[1] の "1" を 2, 3, ..., 18 と連続して 1 ずつ増やしていけばいいわけです。それを 18 回分書く必要はありません。R に限らず世のプログラミング言語には「繰り返し文」という便利な文法が必ずあります。これもまた、まずはやってみましょう。  

```{r}
for(i in 1:nfile){
  fdata[[i]] <- read_csv(fname[i], skip = 19, col_names = F)
  colnames(fdata[[i]]) <- c("freq", "Mag")    # 列に名前をつける
  fdata[[i]]$file <- i                        # ファイル番号を変数として追加（mutate でも良い）
}
```

中身を確認してみましょう。  

```{r}
str(fdata)   # またはコンソールで fdata と実行  
```

18 個分のファイルのデータが区別してリストに格納されました。ここで for 文について説明すると、

```{r results = 'hide'}
for(i in 1:10){
  
}
```

という形をしています。  

* i：インデックス変数。i に限らず j でも x でもなんでも良いが、続く {} の中で指定しておく必要がある。  

* in 1:10："インデックス変数をこのように動かしなさい"という部分。1:10 はベクトルで、1,2,...,10 であるから、インデックス変数を 初期値 1 から 10 まで動かしなさい、という意味になる。ファイルインポートの例では 1:nfile にしていたが、今は nfile = 18 なので、「in 1:18」 と同じ意味。  

* {} ：この中に、繰り返し処理したいコードを書く。インデックス変数を一致させること。  

後ほど練習問題で理解を深めることにして、ここでは先に進みます。  


## 6. リストをデータフレームに変換する  

ここまでで作成したリストは、くどいようですが [[1]]〜[[18]] までの入れ物に区別して格納されていますが、このままでは　ggplot で扱いづらいため、1個のデータフレームに変換します。要は、[[1]] とか [[2]] となっているリスト内部のデータフレームを行の方向にくっつけます。  

```{r}
fdata_df <- bind_rows(fdata)   # リストを行方向にマージ
fdata_df
```

```{r}
str(fdata_df)
```

bind_rows()によりリストはデータフレームに変換されました。各ファイルには 1601 行のデータが入っていましたので、1601 * 18 = 28818 行のデータフレームになっていることが str() の出力からわかります。  

ところでマージの際、どれがどのファイルのデータかわからなくならないように、4 と 5 において、ファイル番号を表す変数 file を作っておきました。fdata_df の 3 列目にあるのがその変数です。これにより、リストをデータフレームにマージしてもどのデータがどのファイル由来かわかるようになっています。このような工夫はインポートする際に重要になります。今回は for 文の中で作成しておきましたが、for 文の中では作らず、リストをデータフレームに変換した後でも可能です。ただし、各ファイルのデータがどのように処理されているのか、過程は把握しておかなければなりません。  

なお、今回は bind_rows() したデータを新しい変数 fdata_df に格納しましたが、リストのデータをその後使うことがないのなら、下のように上書きしてもかまいません。  

```{r}
fdata <- bind_rows(fdata) 
```

最後に、グラフの体裁の関係上、file 変数をファクタ型にしておきます。  

```{r}
fdata$file <- factor(fdata$file)   # ファイル番号をファクタ型に変更
```

## 7. 可視化する  

可視化は今までの復習としてやってみてください。  

ここまでの内容により、たいていのファイルの可視化が自動化できます。グラフの画像を連続的に出力するのだって、for 文を ggplot と組み合わせればできます（練習問題）。後は、ファイルからインポートしたデータを使って新しい評価指標を定義したり（mutate）、データを集計して可視化したり（summarize）、といったように目的に応じた可視化をやってみましょう。  


# 練習問題  

## for 文 Level 1   

以下、for 文を使って

1. 1 から 任意の整数 n までの和と平均値を求めてみましょう。  
　 注：R の関数 sum や mean で求められるし、その方がはるかに高速なので、通常は for 文は使いません。  

2. 1 から 任意の奇数 n までの奇数の和を求めてみましょう（ヒント：奇数のベクトルをインデックス変数に指定する）  

## for 文 Level 2  

for 文と組み合わせて使うと便利な関数に if 文があります。これは条件分岐の関数で、ある条件に合う時と合わないときで処理を変えることができるので、プログラミングで頻繁に登場します。例えばある整数が偶数か、奇数かを判定するには、以下のようになります。  

```{r}
n <- 11
if(n %% 2 == 0){   # %% は剰余（割った余り）を求める演算子
  print("偶数")
} else {
  print("奇数")
}
```

上の例では入力値 n が 2 で割り切れるとき"偶数"、割り切れないとき "奇数" と出力するようになっていますが、"偶数"であることだけ出力すればいいときは、else{} は不要です。  

```{r}
n <- 11
if(n %% 2 == 0){   # %% は剰余（割った余り）を求める演算子
  print("偶数")
} 
```

以上を踏まえて、for 文と if 文を組み合わせて

1. 1 から 任意の奇数 n までの奇数の和を求めてみましょう（インデックスは i in 1:n とすること）  

2. 1 から 任意の整数 n までの間にある、整数 x の倍数の和を求めてみましょう。ただし、n > x とし、インデックスは i in 1:n とすること。  


## データインポート  

exercise フォルダにあるデータはモーションキャプチャのデータファイルで、剛体がひとつ、マーカーが4つのときの各座標値の時間データです。このデータについて、

1. No1.csv についてデータをインポートしましょう。  

2. 時間（Time）と剛体（Rigid）の位置座標（Position X,Y,Z）のみを取り出してみましょう。  

3. 2 のデータについて 時間 vs 座標のグラフを描き、画像ファイルとして出力しましょう。  
   グラフの画像出力は以下のように ggsave() で実行可能です。  
   また、できればグラフの体裁も調整してみましょう（"Level 1 - Geom を知る" 参照）。  
　 
　 
```{r echo=TRUE, message=FALSE, eval = FALSE}
# グラフの画像出力
ggplot(mpg, aes(displ, hwy, col = class)) +
  geom_point() 
ggsave("image.png", width = 16, height = 8, units = "cm")
```

4. No1 〜 No4 のファイルに対して、1〜3 の処理を連続処理してみましょう。画像ファイルも連続出力してみましょう（ヒント：ggsave のファイル名を paste0 で作成する）。  



