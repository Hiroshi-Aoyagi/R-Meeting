---
title: "Level3 - データインポートと可視化"
output: 
 html_notebook:
   css: font-style.css
---

前回までで実験データの可視化の準備は整いました。  

**今回の主な内容は外部データを読み込んで、可視化に適した構造のデータフレーム - 1行1レコードのデータフレームを作成することです**。ただし、これだけ分かれば外部データの可視化はできるものの、実験から得られた同じ形式のデータファイルがたくさんあって、そのすべてを可視化したいとき、1個ずつ処理するコードを書くのは大変です。コピペすればファイルが数個くらいならそれでもいいですが、もっとスマートに、高速にやりたいものです。  

というわけで、複数の同形式のファイルがあるときの（ちょっとした）自動化も取り上げます。  

* 1個のデータファイルからデータフレームを作成する方法  
* 複数のデータファイルからデータフレームを作成する方法  

今回もライブラリを使いますので、以下のチャンクを実行しておいてください。  

```{r results = 'hide'}
library(tidyverse)
```

# 1個のデータファイルからデータフレームを作成する方法  

## データファイルのインポート  

今回は時間 vs 加速度のデータを例題として使います。Rstudio のプロジェクトフォルダの直下に、Github からダウンロードした sample というフォルダをコピーしておいてください。フォルダの中にはテキストファイルが2つ入っていますが、どちらでもいいのでテキストエディタで開いてどんなファイルなのかざっくり把握してください。  

それでは例のごとく、まずはやってみましょう。  

```{r}
# データのインポート
read_csv("./sample/CH1_TS.txt",    # ファイル名をダブルクォーテーションで囲って指定
         skip = 16,                # 冒頭 16 行はインポートしない
         col_names  = F)           # 各列の名前はなし
```

インポートできました。コメントでなんとなく分かると思いますが、少し詳しく説明すると...  

* read_csv：
  csv ファイルをインポートする関数。拡張子が csv でなくても、内容がカンマ区切りならインポートできる。  

* "./sample/CH1_TS.txt"：  
  インポートするファイルの場所と名前を指定（下記に補足）。

* read_csv の skip：  
  今回指定したファイル CH1_TS.txt は、冒頭16行目までヘッダー情報で、必要ありません。計測システムによってこういったヘッダーが追加されますので、事前に行数を確認しておきます。  
  
* read_csv の col_names = F：  
  今回のファイルには列が 2 つありますが、それぞれの列には名前がついていません（正確にはヘッダー情報に示されてはいるのですが、read_csv では認識できません）。そのため、F（False）を指定して列名がない、という指定をしています。  

> インポートするファイルと場所の指定
./sample/ までがファイルの場所で、ピリオド "." は現在の作業フォルダを意味する。したがって、./sample/ は、"今の作業フォルダにある sample というフォルダの中身" という指定をしている。ちなみに、ピリオド 2 つ ".." は「現在の作業フォルダの 1 つ上のフォルダ」という意味。二重で指定すると "../../" 上の上のフォルダ、となる（3重以上も指定可能）。この指定の仕方は R に限らず、その他の言語でも共通している。なお、「現在の作業フォルダ」は、プロジェクトを作成するときに指定したフォルダ。getwd() で現在のフォルダを確認することができる。


以上の設定で読み込みを実行すると、R が自動的に読み込むデータの型（今回は double 型の変数と認識）を認識し、さらに列の数も認識し、無事 2 列分を読み込みました。  

上の実行例はとりあえず読み込んだだけなので、そのままでは使えません。読み込んだ結果を適当な名前のオブジェクトに代入しておけば、後で使えます。read_csv に限らず R の関数は 1 行で実行しても良いので下の例では書き直しました。  

```{r}
ch1 <- read_csv("./sample/CH1_TS.txt", skip = 16, col_names  = F) 
```

データの中身を見ておきましょう。  

```{r}
ch1
```

読み込んだときは、データの型やデータの数（行数や列数）などを確認する癖をつけておくと後々のトラブルを防げます。  

```{r}
class(ch1)
```

```{r}
str(ch1)
```

今回はきちんと、クラスはデータフレーム、各列の型は double、列数 2、行数 4,096 で意図した読み込みができたと判断できました。  

ここでひとつ気になるのが列の名前です。str の出力などから、1列目の列名は X1, 2列目の列名は X2 となっていますが、これは読み込んだ順番に X に数字をつけていくようになっています。これだと何の変数なんだかわかりづらいので、普通は名前を変えます。  

```{r}
# 列の名前を変える  
colnames(ch1) <- c("Time", "Acceleration")
```

```{r}
ch1
```

列名が変わりました。X1 と X2 の両方を同時に変更したので、c() によりベクトルで名前を指定します。  

ところで、列名がある場合のデータファイルはどんな感じなのか、同じく sample フォルダの CH1_TS_Colnames.txt を開いてみてください。17行目に列名の行が入っているのにご注目。このファイルを読み込むときは次のようになります。    

```{r}
ch1 <- read_csv("./sample/CH1_TS_Colnames.txt", skip = 16, col_names = T)  # col_names = T に変更
```

```{r}
ch1
```

この場合はファイルに記載の列名が読み込まれますので、colnames() で列名を変更する必要がありません。  

このファイルに関しては、インポートはこれで終了です。列数が 2 つしかなく、1行1レコードになっているのでこれ以上のデータ操作も必要ありません。せっかくなのでグラフを描いてみてください。  

ここではもっとも頻度が高いと思われるカンマ区切りデータのインポート方法でしたが、ほぼ同じ手順で別の形式のデータもインポートできます。  

* read_tsv：タブ区切りのファイルをインポート  
* read_delim：区切り文字を指定してインポート（汎用的だが、動作がのろい気がする）  

skip や col_names の指定方法は同じです。場合に応じて使い分けましょう。  

## データ型の修正  

double 型のデータの場合はここまでやった通り、インポートであまり問題が起きません。しかし、int 型（整数型）では問題が起きることがあります。これは目的によるのですが、その整数を連続的な数値として扱いたい場合は良いのですが、ファクタ factor 型として扱いたい場合は後処理が必要になります。  

例えば、1, 3, 4, 7 という数値があったとき、これが点数（大きさに意味がある）なのか、アンケートでの水準の値（大きさには意味がなく、選択肢の区別として意味がある）なのか、ぱっと見では判別できません。R はそんな判断はできないので、インポートするときは整数型でインポートします。この差は可視化をするときにも影響があります。以下に例を示しますが、データフレームの作成の過程はわからなくてもOKです。  

```{r}
# 例の作成
x <- seq(0, 2, length.out = 11)
test.df <- tibble(
  x = x,
  y1 = x,
  y2 = x^2,
  y3 = x^3
)
test.df <- test.df %>%
  gather(y1:y3, key = y, value = val) %>%
  select(-y)
test.df$y <- rep(1:3, each = 11)
```

```{r}
test.df
```

このデータフレームは、x が x 軸の値、val が各関数の値、y が関数の識別番号、という想定です。y の型は int 型になっています。つまり、データの大きさに意味がある、という風に認識されています。このデータフレームで 3 つの関数のグラフを重ね書きして、色で区別したい、としましょう。  

```{r}
# グラフ描画
ggplot(test.df, aes(x, val, group = y, col = y)) +
  geom_line()
```

あれ？なんか色がグラデーションになっててわかりづらい...　と思いませんか？こういうグラフが描きたいことももちろんありますが、もっとはっきり色を区別して欲しい、というときはデータに修正が必要です。その修正とは、y のデータ型を ファクタ型または文字型に変えてしまうことです。  

```{r}
# 型の変更  
test.df$y_fct <- factor(test.df$y)        # ファクタ型にする場合
test.df$y_chr <- as.character(test.df$y)  # 文字型にする場合
test.df
```

本当は y の列はもう不要なので上書きしても良いのですが、今回は変化に着目しているので残したまま列を追加しました。y_fct はファクタ型（fct）、y_chr は文字型（chr）になっています。見かけ上は同じですが、内部的な型が異なります。これで再度可視化してみましょう。  

```{r}
# グラフ描画 - ファクタ型で色付け
ggplot(test.df, aes(x, val, col = y_fct)) +
  geom_line()
```

```{r}
# グラフ描画 - 文字型で色付け
ggplot(test.df, aes(x, val, col = y_chr)) +
  geom_line()
```

色づけの仕方が変わりました。こっちの方が意図した可視化だ！という場合はこうしましょう。  

ひとつ注意点は、今回はファクタ型も文字型も同じグラフになりましたが、両者は違いがあることです。それは順序があるか。ファクタ型は順序がありますが、文字型はありません。今回はたまたまファクタ型の順序と文字型の表示される順序が一致しただけ、ということになります。  

ファクタ型はデフォルトで、作成するときに指定したベクトルの要素の順に順序をつけます。上の例におけるファクタ型への型変更では、test.df の　y の列を factor() で指定しました。この中身は    

```{r}
test.df$y
```

となっていて、1,2,3 の順に登場します。この順番で順序付けされたということです。これは実行後に確認できます。  

```{r}
test.df$y_fct
```

Levels: となっているところが順序を示し、左の方が上位に当たります。  

factor() では、引数 levels で順序を明示的に指定することができるので、順序を変えることでグラフの色付けも変えられます。

```{r}
test.df$y_fct <- factor(test.df$y_fct, levels = c(3, 2, 1))
```

```{r}
# グラフ描画 - ファクタ型で色付け
ggplot(test.df, aes(x, val, col = y_fct)) +
  geom_line()
```

色付けが逆順になりました。levels での指定により、もちろん他のパターンも可能です。  

型の変更は、read_csv でインポートしたときに意図しない型で読み込まれた時に行うようにしましょう。  


（つづく）  


