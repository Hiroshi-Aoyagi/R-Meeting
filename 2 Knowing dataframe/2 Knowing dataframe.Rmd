---
title: "Level2 - データフレームを知る"
output: 
 html_notebook:
   css: font-style.css
---

前回は Geom を知る、ということで可視化に適したデータがある前提で話を進めました。進めるうちに、次のような疑問が湧いた方がいると思います。  

* データをどういうふうに用意すればいいのか  
* データはどんな構造をもっているのか  
* 数値を表すデータだったり文字列だったり、何なのか  

今回は可視化に必要なデータ構造を知ることについて深堀したいと思います。 
具体的には以下の内容を取り上げます。

* データフレーム  
  * データフレームはベクトルからできている  
  * データの型とクラス  
  * クラスとリスト  
* 可視化のためのフィルタリング
  * パイプ %>%
  * filter  
  * select  
  * mutate  
  * summarize & group_by  
  * arrange  


今回もライブラリを使いますので、以下のチャンクを実行しておいてください。  

```{r results = 'hide'}
library(tidyverse)
```


# データフレーム  

Rではいろんなデータ形式があります。細かい説明は後ですることにして、まずは以下の点を覚えてください。  

<font size = 5５pt, color = "blue">
可視化で重要な形式は データフレーム dataframe  
</font>

今まで扱ってきたサンプルデータ、mpg や　diamonds はデータフレームです。  

データフレームとは何か、今までも何度も見てきましたがじっくり見てみましょう。  

```{r}
mpg   # Ctrl + Enter で実行
```

右側にも続いているのですが、見づらいと感じる方はコンソール（この画面の左下に Console とあるところをクリック）で View(mpg) と実行してみてください。  

データフレームの特徴を書いてみると:  

1. 列ごとに異なる種類のデータが並んでいる
2. 各列のラベルの下に "chr" とか、"dbl" とかと表示される  
3. 各列にはラベル（変数名）がつけられている(manufacturer, model, ...)  
4. すべての列の行数は等しい  

最後の項目は上の出力の左下にある、"1-10 of 234 rows" からもわかるのですが、データフレームのサイズを確認する方法を2つ紹介します。  

```{r}
# データフレームサイズの確認方法①
str(mpg)
```

前回も紹介した str() の出力を見ると、縦にデータフレームの列の変数が並んでいて "[1:234]" となっているところが各列変数の長さを表しています。mpg の場合は 234 行のデータがあるのがわかります。みんな等しいです。  
（または 出力冒頭の  "tibble [234 × 11]" を見れば 234行11列のデータとわかります）。  

```{r}
# データフレームサイズの確認方法②
dim(mpg)
```

dim() は初登場ですが、dimension の略でデータフレームなどのサイズを知りたいときに使います。これもすぐわかりますが、初めの234が行数、11が列数です。　

ggplot() + geom_*** で可視化するときは、 aes(displ, hwy) などと指定していましたが、使用するデータフレームの列の名前に対応していました。  

逆に言うと、データフレームは上に示した特徴をもつように作成する必要があります。**中でも特に重要なのは 4番で、行数は揃えないといけません。**


## データフレームはベクトルからできている  

続いてデータフレームの作り方、といきたいところなのですが、その前に知っておいた方が良いのがベクトルというデータ形式です。簡単に言うとデータフレームはベクトルからできている、と考えて良いです。具体的には、**データフレームの各列のデータがベクトルです**。例えば、mpg の1列目は次のようにしてベクトルとして取り出せます。  

```{r}
# データフレームからベクトルを取り出す
mpg$manufacturer   # ドル記号 $ をかまして 列名を入力する
```

manufacturer 列はクルマのメーカー名が並んでいましたが、それだけ取り出しました。出力の一番左に [1] とか [8] とか書いてありますが、例えば [204] の行は、「204番目から210番目までのデータだよ」、ということを示しています。なんで最後が210番目と分かるかというと、[204] の下にあるのが[211]だからです。次の行は211番目から始まるので、[204]行の最後は 210番目、という感じです。取り出した順番は、もとのデータフレームのままです。本当か？と思う方は View(mpg)の出力とベクトルの出力を比べてみてください。  

ベクトルの出力はいつもこれと同じように表示されます。他の列も取り出してみましょう。  

```{r}
# データフレームからベクトルを取り出す
mpg$cty
```

cty は各クルマの都市部における燃費（マイル/ガロン）を表していますので、数値が並んでます。メーカー名と違って1データあたり2文字分しか取らないので、1行にたくさんのデータが表示されます。  

というわけで、データフレームがベクトルというものからできているのを分かって頂けたんではないかと思います。  

ところでベクトル（vector）は、高校数学で習ったベクトルと同じ意味です。XY平面上の点Aの位置を表すのに、$\vec{A} = (2,1)$ （注：$記号のあたりにマウスポインタを置いてみてください。htmlファイルでは数式になります）かと表記していたと思います。これは2次元ベクトルと言ってましたよね。3次元ベクトルだと成分が3つになってましたが、より一般的にはn次元ベクトルでデータ列を表現できます。4次元超えると図形的なイメージは人間にはできませんが、定義することはできます。  

今回の場合、各列変数には 234 個のデータがあって、その中の1つの列をベクトルとして取り出しました。そのため、取り出したベクトルは　234 個の成分からなるベクトル（234次元ベクトル）ということになります。  

ベクトルは長いと表示が見づらいことが多いです。そんなときは次の関数が便利です。  

```{r}
# 冒頭だけ表示する
head(mpg$cty, 10)
```

```{r}
# 最後だけ表示する
tail(mpg$cty, 10)
```

headは冒頭から、tailは最後から何番目まで表示するかを指定して出力します。10 を省略するとデフォルトで 6番目まで表示します。  

### データのさらなる取り出し（抽出）

以下、少し脱線です。ベクトルの成分は、[ ]で抽出することができます。  

```{r}
# ベクトルの成分の抽出
mpg$cty[1]
```

mpg$cty の後ろに [1] とつけると、ベクトルの1番目のデータだけ取り出せます。他の番号（234以下の整数）でも試してみてください。  

また、ある範囲のデータを抜き出すこともできます。  

```{r}
# ベクトルの複数成分の抽出
mpg$cty[20:30]
```

20:30 と指定すると、20番目から30番目までを抜き出す、という意味になります。  
または、指定した番号以外の成分を抽出したい、というときもあるでしょう。  

```{r}
# ベクトルの複数成分の抽出：指定した番号以外の成分を抽出する
mpg$cty[-(20:180)]
```

この例では、20番目から180番目以外のデータを抽出してます。つまり1〜19番目と、181〜234番目までが抽出されています。マイナス - をつけることで可能ですが、複数指定する場合は -() とします。  

連続していなければだめなのか？と思った方、不連続でもいけます。少し手間がかかりますが...  

```{r}
# ベクトルの複数成分の抽出2
mpg$cty[c(2, 20, 42, 67, 89, 95)]
```

c() で抜き出したい番号をカンマ区切りで指定して、[ ] の中に入れてあげます。実行例では、2番目、20番目、42番目、67番目、89番目、95番目 だけを抜き出しました。c() についてはすぐ後に説明がありますので少し待ってください。  

なんか条件をつけて抜き出したいってこともあるだろう、という方、それもできます。例えばメーカーがアウディのデータだけとか、燃費が 20以下のデータだけとか...  

```{r}
# 条件によってデータを抽出する
mpg$manufacturer[mpg$manufacturer == "audi"]
```

イコールが二重になっているのは間違いではありません。たいていのプログラミング言語では、二重のイコール "==" は「左辺と右辺が等しいか？」を判定する演算子です。上の例では、manufacturer が audi に等しいかを判定していて、それが正しい（"真"（TRUE）、といいます）データだけを抽出する意味になっています（正しくないときは、"偽"(FALSE)といいます）。  

ちなみに "audi"ではないメーカーを探すときは以下のようになります。  

```{r}
# 条件によってデータを抽出する
mpg$manufacturer[mpg$manufacturer != "audi"]
```

!= は、「イコールでない」を意味するこれまた演算子です。"audi"以外が出力されました。  

```{r}
# 条件によってデータを抽出する2
mpg$cty[mpg$cty < 20]
```

実際の応用では、例えば「cty が 20以上のクルマメーカーは？」というように、「変数Aがある条件を満たすときの変数Bのデータ」 を抽出したいことが多いですよね。そういうときは...  

```{r}
# 条件によってデータを抽出する2
mpg$manufacturer[mpg$cty > 20]
```

あくまでサンプルデータセットの中ではありますが、これだけでも「日本車は比較的燃費が良い」、という分析ができそうですね。  

脱線終わり。  


## データの型とクラス  

それではデータフレームの作成にいきましょう、とはいかないのです。データフレームはベクトルからできている、と説明したので、ベクトルの作成方法から説明します。遠回りのような気がしますが、ベクトルの作成方法がわかればデータフレームの作成は簡単です。  

前項ではできあいのデータフレームからベクトルを抽出する方法を説明しましたが、これはあくまでデータフレームがどういうものかイメージしてもらうため。本来は自分でベクトルからデータフレームを作成したり、後日説明しますがデータファイルから読み込んでデータフレームを作成したりします。順序が逆になりますので、**ここでちょっと思考を切り替えてください**。  

### データの型  

前置きが長くなりましたが、ベクトルを作成するにあたって知っておかなければならないのがデータの型(type)です。R（と他の言語）の代表的な型は以下の6つがあります。  

* 整数型: int ... integer から来ている。名前の通り整数。    
* 実数型: dbl ... double から来ている。倍精度浮動小数点型（要は小数点以下も含めた数値のこと）  
* 文字型: chr ... character から来ている。名前の通り文字や文字列。  
* 論理型: logical ... TRUE(1) か FALSE（0) のみをもつ。  
* 複素数型: complex ... そのまんま。実部と虚部をもつ。  
* ファクタ型: fct ... factor から来ている。int または character の見た目だが、順位をもっているもの。  

なんか見覚えありますよね。 str() とか、mpg を実行したときに出てきてました（見覚えない方は冒頭の方の実行例を見直してみてください）。あれはデータの型でした。  

自分で作成するベクトルのうち 90% くらいは int, dbl, chr ですのでこれらをメインに説明します。ちなみに複素数型なんかいつ使うんだ？と思うかもしれませんが、FFT（高速フーリエ変換）して時間データを周波数データに変換すると出てくる、という意味では割と目にするかもしれません（FFTは fft(x) （x は int または dbl のベクトル）で実行できる、とだけ紹介してておきます）。  

### ベクトルの作成方法とデータ型の確認方法

さっそくやってみましょう。まずはもっとも簡単な int から。  

```{r}
# 連続の整数型ベクトルを作成する
x <- 1:10  # Ctrl + Shift + Enter で実行
x
```

1:10とか、コロンで挟むと刻みが1の整数ベクトルを作成してくれます。<- は「右側のデータを左のパラメータに代入する」という意味の演算子です（= でも同じ意味なのですが、Rでは <-　を慣習的に使う人が多いようです）。したがって、x <- 1:10 は、x に 1:10 というベクトルを代入する、という意味です。  

データの型は typeof() で確認できます。これは整数型だけでなく、どんな型でも確認できます。    

```{r}
# データの型を確認する
typeof(x)
```

```{r}
# 連続の整数型ベクトルを作成する
x <- 10:1
x
```

指定する数値は逆でもOKです。

```{r}
# 連続の整数型ベクトルを作成する
x <- -10:10
x
```

マイナス値の指定もいけます。  

連続値ではない方法で、これも簡単な規則性のあるやり方から。  

```{r}
# 整数型ベクトルを作成する - 規則性あり1
x <- seq(from = 0, to = 10, by = 2)
x
```
 seq() は sequential（シーケンシャル）から来てます。引数の意味はなんとなくわかるんではないかと思います。from = , to = , by = の部分は省略できます（seq(0, 10, 2)で良い）。   
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(2, times = 10)
x
```

rep は　replicate（繰り返し）から来ていて、数値を指定回数繰り返したベクトルを出力します。  
seq と同様に、times = は省略できます。  
 
rep は次のような使い方も可能です。
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(1:5, 3)
x
```
 この場合、1:5 を3回繰り返します。もうひとつあります。  
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(1:5, each = 3)
x
```
第2引数を each = とすることでそれぞれを 3 回ずつ繰り返し、というパターンになります。  

seq や rep は一見すると、「そんな単純な整数列作って何になるんだ」と思いますが、これが意外に結構使います。今は使わなくてもそのうち使うはずなので、こんなんあるんだ、くらいで覚えておくと良いです。  
 
さらに一般的な整数数列を作りたいときは、c() を使います。  

```{r}
# 整数型ベクトルを作成する - 規則性なし
x <- c(-3, 5, 1000, -213, 77, 84)
x
```

c() の c は combine（組み合わせ）から来ています。ベクトルをつなげる機能をもっています、というのが正しい説明なのですが、少し補足。Rでは1つの変数もベクトルです。例えば、  

```{r}
x <- 5
x
```

出力に注目してください。x には 5 という数値1つだけが代入されるのですが、出力には [1] が左側についています。つまり、x は長さ1のベクトルです。というわけで、c(-3, 5, 1000, -213, 77, 84) は、長さ1のベクトル -3, 5, 1000, -213, 77, 84 を1つのベクトルにつなげて長さ5のベクトルを作成する、という意味です。補足終わり。  

このベクトルも、rep と組み合わせられます。  

```{r}
# 整数型ベクトルを作成する - 規則性なしを繰り返す
rep(x, 5)
```

-------------------------------------------------------------------------------------------

続いて dbl 型ですが、基本的な作り方は int 型と共通です。 

```{r}
# dbl型
x <- seq(0, 10, length.out = 5)
x
```

seq の第2引数を length.out にして、一定間隔で小数点以下を含む実数を作成しました。length.out は int でも使えますが、ちょうど割り切れないと dbl 型になります。  

```{r}
typeof(x)
```

気づいた方もいると思いますが、ベクトルはひとつの型しかもてません。int 型と dbl 型を混在できないのは上の例からわかると思います。 0.0 や 5.0 は 0 や 5 と等しく int 型でも良いのですが、他の数値が　dbl 型なので、そっちに合わせられています。というわけで、データ型には階層構造（上位、下位）があるのですがあんまり気にしなくても良いので先にいきます。  

rep() や c()　の使い方も int 型と同じです。  

```{r}
rep(x, 3)
```

-------------------------------------------------------------------------------------------------

chr 型も基本は同じですが、seq は使えません。文字型の場合は文字列を ダブルクォーテーションまたはシングルクォーテーションで囲む必要があります。  

```{r}
# chr 型
x <- c("apple", "orange", "banana")
x
```

```{r}
typeof(x)
```

rep() は chr 型でも使えます。 

```{r}
rep(x, 3)
```

文字列は文章みたいに長くても良いです。tidyverse にある例を見てみましょう。  

```{r}
head(sentences)
```

```{r}
typeof(sentences)
```

ちなみに日本語可です。  

```{r}
x <- c("リンゴ", "オレンジ", "バナナ")
x
```

文字列を操作する関数もたくさんあって、可視化のときに便利なことがあるのですが、ここではベクトルの作成方法が主目的なので省略します。可視化の際に機会があれば触れたいと思います。  


## クラスとリスト  

### データフレームの作成と型、クラスの関係    

さて、ようやくデータフレームの作成です。まずは作成してみましょう。ベクトルの作成も含めてやってみます。  

```{r}
df <- tibble(
  x = 1:5,
  y = seq(-2, 5, length.out = 5),
  z = c("SS400", "S45C", "ADC12", "C1100", "PP")
)
df
```

tibble() というのがデータフレームを作成する関数で、内容が x, y, z という変数で、それぞれ長さ 5 で統一されたベクトルになっていることに注意してください。  

これだけです。作成したデータフレーム df に typeof() を適用してみると...

```{r}
typeof(df)
```

データフレームにも型があり、リスト、という名前がついています。  

ちょっとわかりづらいのですが、Rではデータ形式の分類としてデータ型（type）の他にクラス（class）があります。 

```{r}
class(df)
```

クラスを確認する関数はそのまま class()。これを実行すると data.frame と出てきました。つまり、データフレームの型はリスト、クラスはデータフレーム、ということになります。で、これは私見ですが、概念としては型の方が上位と考えた方が整理しやすいので、リストの中のデータフレーム、と理解すると良いと思います。  

その上でもう一度 class の出力を見ると、"data.frame" のほかに "tbl_df", "tbl" とあります。これらもデータフレームとほぼ同じものと考えて差し支えありませんが、若干違います。data.frame は base R にもともとあるクラスなのですが、どうも古くなってしまったようで使い勝手が悪い場合があるようです。そこでそれを改良したのが tbl で、これは tibble の略です。データフレームの作成で tibble() を使ったのはこれです。したがってデータフレームは data.frame() でも作れますが、今回の勉強会ではそうする必要がないので使いません。  

### リスト  

リストは型である、ということなのですが単なる概念ではなくちゃんと実体があります。可視化では多数の外部データを読み込むための一時保存場所として使うと便利なので、ここで紹介しておきたいと思います。まずは作ってみましょう。  

```{r}
# リストの作成
a <- list(x = 1:3, y = c("apple", "orange", "banana", "grape"), z = df)
a
```

リストの出力（notebook上では2つ出力が出てきますが左側のパネルをクリック）を見ると、x, y, z が $ マークで分かれていて、それぞれの内容が指定したベクトルやデータフレームになっています。また出力はデータフレームのように列ごとにはなっておらず、縦に並んでいます。  

ここで特に気づいて欲しいのは、リストの各中身の長さは違っていても良いという点です。例えば x は長さ 3 のベクトル、y は長さ 4 のベクトル、z は5行3列のデータフレームとなっていて、こういう風にデータの型やクラスに関わらず1つの変数（オブジェクト）に格納できるのが利点です。  

クラスも調べてみましょう。当然ですが、リストです。  

```{r}
# リストのクラスを確認
class(a)
```

リストのデータを抽出する方法も紹介します。  

```{r}
# リストからのデータ抽出
a$x
```

```{r}
# リストからのデータ抽出
a$y
```

```{r}
# リストからのデータ抽出
a$z
```

$ 記号で変数を指定すれば抽出できるのはデータフレームと同じです。  


# 可視化のためのフィルタリング  

データフレームの基本は以上です。ここからは可視化のためにデータフレームを操作する方法について説明します。  

Level 1 ではすでにあるデータフレームをそのまま使って可視化の方法を紹介しましたが、実はデータフレーム自体は何も操作していませんでした。そのためみなさん、Level 1　をやっていてこうは思いませんでしたか？  

* diamonds の cut が Ideal のデータだけのグラフを描きたい  
* diamonds の carat が 0.5 以下のデータだけのグラフを描きたい  
* mpg で都市部の燃費 cty と高速道路 hwy の比のグラフを描きたい  

そういうことをやってみましょう。ここでは以下の内容を取り上げます。    

* %>%
* filter  
* mutate  
* select  
* summarize & group_by  
* gather & spread
* arrange  


以上はすべてパッケージ tidyverse に含まれる dplyr というパッケージの関数ですので、ライブラリのロードが必要です。ここから読み始める方は以下を実行しておいてください。  

```{r results='hide'}
library(tidyverse)   # Ctrl + Enter で実行
```


## パイプ %>%  

パイプを知らなくてもデータフレームを操作することはできますが、知っているのといないのでは操作の効率と、コードが見やすくなる点が違います。言葉で説明するとわかりづらいのでまずはやってみましょう。  

```{r}
# パイプを使う場合
diamonds %>%
  filter(cut == "Ideal") %>%
  filter(carat < 0.25)
```

上のコードは、cut が "Ideal"で、かつ carat < 0.25 だけのデータを抜き出しています。filter の機能 はあとで説明しますが、なんとなくやっていることはわかったのではないでしょうか。次にパイプ無しで同じことをやるとどうなるか見てみましょう。  

```{r}
# パイプ無しの場合
diamonds.Ideal <- filter(diamonds, cut == "Ideal")
diamonds.Ideal.carat_lt_0.2 <- filter(diamonds.Ideal, carat < 0.25)
diamonds.Ideal.carat_lt_0.2
```

パイプ有りと無しで出力が同じであることをご確認ください。コードを見比べてみると、パイプ無しの問題点が浮かんできます。  

* 前回のフィルター結果を新しい変数に保存（格納）しておかなければならない  
* したがって変数が増えてしまい、どの変数に何を保存したか覚えておく必要がある（面倒くさい！）  
* そのためにどんな変数なのかを変数名に反映させると、どんどん長くなっていく（見づらい！）
* 次のフィルターのために、変数名を重複して打ち込まなければならない（上の例では diamonds.Ideal と diamons.Ideal.carat_lt_0.2 を2度ずつ打ち込んでいる）  

こういう問題を解決してくれるのがパイプ %>% だと思ってください。上の例のとおりパイプは  

<big>

%>% の左側の実行結果を %>% の右側の関数に渡す  

</big>

という働きをします。したがって、中間結果を別の変数に保存しておく必要がありません。

まだ十分に理解できていなくても、以下の内容を読んでもらえばなんとなく使えるようになると思います。  

## filter: データを制限する  

上の例でも出てきましたが、条件式によってデータを制限する関数です。== とか < を比較演算子と言いますが、<, <=, >, >=, ==, != があります。<= と >= は、"以下"、"以上" で、数値を含みます。< と > は数値を含みません。  

```{r}
mpg %>%
  filter(hwy < 20)  # 20 は含まない
```

```{r}
mpg %>%
  filter(drv != 4)
```

また、比較演算子を複数組み合わせて複数の条件で制限をかけたいときがあります。こういうときは論理演算子 & (and), | (or)  を使います。早速やってみましょう。  ）

```{r}
mpg %>%
  filter(hwy < 20 & cty < 10) # hwy < 20 かつ cty < 10 
```

```{r}
mpg %>%
  filter(hwy < 20 | cty < 10) # hwy < 20 または cty < 10
```

文字型変数の場合は、条件式の文字列をダブルクォーテーション "" または シングルクォーテーション '' で囲むことに注意してください。  

```{r}
mpg %>%
  filter(manufacturer == "honda" & year == 1999)
```

filter したデータを使って可視化をするとき、毎回 filter のコードを書くのは面倒なので、別の変数に保存しておくと良いです。  

```{r}
mpg2 <- mpg %>%          # filter 結果を mpg2 に格納
  filter(manufacturer == "honda" & year == 1999)
mpg2
```

## mutate: 変数を作成する    

データフレームに含まれる変数から新しい変数を演算によって作成したいことがあります。こういうときは mutate を使います。  
```{r}
# 変数の作成
mpg3 <- mpg %>%
  mutate(
    raio = hwy/cty    # 高速と都市の燃費の比を計算し、その結果を ratio に格納する
  )
str(mpg3)
```
最後の列（上の表だと一番下）に ratio が追加されます。mutate はこのように一番後ろの列にどんどん変数が追加されていきます。その結果、データフレームの見通しが悪くなることがあります。例えば、ちゃんと作成されたかどうかを str ではなくて次のように確認したいときです。  

```{r}
mpg3  # Ctrl + Enter
```

これだと列数が画面に収まりきらないので、ちゃんと作成されたかわかりません。そのため str() を使いました。  

こういうとき、よく使いそうな変数はデータフレームの左側に配置させておきたい、というときもあろうかと思います。いくつか方法がありますが、ここでは mutate の仲間の transmute を紹介します。  

```{r}
# transmute：新しい変数をまっさらなデータフレームに作成する
mpg4 <- mpg %>%
  transmute(
    ratio = hwy/cty
  )
mpg4
```

transmute を使うと、作成した変数だけのデータフレームが出力されます。残しておきたい列がある場合は、次のようにするか、後で紹介する select を使うと良いです。  

```{r}
mpg4 <- mpg %>%
  transmute(
    class = class,
    ratio = hwy/cty,
    hwy = hwy,
    cty = cty
  )
mpg4
```

class = class という風に自分自身をイコールにしている部分は、「mpg に入っている変数 class（右辺） を、新しい変数 class （左辺）に代入せよ」という意味です。ちょっと冗長な感じですよね。  
このようにして作成したデータフレームは、可視化に普通に使えます。次の例ではパイプも使っています。  

```{r fig.width=10, fig.height=4}
mpg4 %>%
  ggplot(aes(class, ratio)) +
  geom_boxplot() +
  theme(text = element_text(size = rel(4.5)))
```

## select：変数を選択する  

mutate の項で触れた select をここで紹介しましょう。transmute で何も変更のない変数を "class = class"のようにして入力するのは冗長な感じでしたが、select の方が簡単です。  

```{r}
mpg5 <- mpg %>%
  select(class, hwy, cty) %>%
  mutate(                          # trasmute → mutate  に注意
    ratio = hwy/cty
  )
mpg5
```

select は選ぶ順番に元のデータフレームに含まれる変数名を指定することでその変数だけを抽出します。  

transmute にしていたところを mutate に変更している点に注意してください。transmute にすると、ratio だけしか残りません（気になる人は試してみてください）。  

上の例、select と muttate を逆にしても良いですが、最後の select に ratio を含めるのを忘れずに。  

```{r}
mpg5 <- mpg %>%
  mutate(
    ratio = hwy/cty
  ) %>%
  select(class, hwy, cty, ratio)
mpg5
```

変数をまとめて選択したいとき、全部入力してもいいのですが楽できる場合があります。次の例では manufacturer から cyl まで隣り合っている列をまるごと選択しています。間にある model や displ なども選択されます。  

```{r}
# まとめて選択
mpg6 <- mpg %>%
  select(manufacturer:cyl)   # コロンで区切る  
mpg6
```

この方法は連続した列にしか適用できません。そういう場合、むしろ非選択にした方がカンタン、というときには次の方法があります。  

```{r}
# 非選択
mpg6 <- mpg %>%
  select(-model, -(cty:class))
mpg6
```
上の例では、model と cty から class までの連続した列を非選択しています。マイナスをつけるとそうなります。  

## summaraize & group_by: データの要約量などを求める  

大量のデータ（情報）をあまさず使って分析するのが良いと言われていますが、人間、多すぎるデータに目が回る。。。ということも多分にあります（少なくとも私は）。そういうときは大体の傾向をつかむために平均値とか中央値とか、変動の幅とかを取りたいことがあります。そういうときに役立つのが summarize & group_by です。  

summarize が要約量を出す機能を受け持ち、group_by はグループ（水準）を分けるときに使います。例えば、クルマメーカーごとに cty の平均値を出したい、というとき、"クルマメーカーごと"の部分を group_by がやってくれます。例のごとくやってみましょう。  

```{r}
# クルマメーカーごとの燃費を出力する
mpg7 <- mpg %>%
  group_by(manufacturer) %>%
  summarize(
    mean_cty = mean(cty),
    mean_hwy = mean(hwy)
  )
mpg7
```

mpg7 はデータフレームなので、これを使って可視化ができます。上のようなデータでは、棒グラフとか描きたくなるかもしれません。  

```{r fig.width=10, fig.height=3}
mpg7 %>%
  ggplot(aes(manufacturer, mean_cty)) +
  geom_bar(stat = "identity")
```

group_by をかまさないとどうなるでしょうか。  

```{r}
mpg %>%
  # group_by(manufacturer) %>%    # Ctrl + Shift + C でコメントアウト
  summarize(
    mean_cty = mean(cty),
    mean_hwy = mean(hwy)
  )
```

予想したと思いますが、"クルマメーカーごと"のグループ分けをしないので、全部のクルマメーカーの平均値しか出力しません。それが目的なら、これでOKです。  

グループ分けはさらに細分化可能です。次の例では、クルマメーカーと気筒数で平均値を出します。  

```{r}
# クルマメーカーと気筒数での平均値
mpg8 <- mpg %>%
  group_by(manufacturer, cyl) %>%  # 2つの変数でグループ化
  summarize(
    mean_cty = mean(cty),
    mean_hwy = mean(hwy)
  )
mpg8
```

グループ化はいくつの変数でも可能です。  

ところで、ここまででお気づきの通り summarize を使うには mean などの要約量を出す関数を知らないといけません。代表的な関数を以下に挙げておきます。  

* mean : 平均値  
* median : 中央値  
* quantile : 分位数  
* max : 最大値  
* min : 最小値  
* sd : 標準偏差  
* var : 分散  
* n : カウント　

ここでは quantile と n の使い方を紹介しておきます。  

```{r}
mpg %>%
  group_by(class) %>%
  summarize(
    cty25 = quantile(cty, probs = 0.25),   # cty の 25% 分位点
    cty75 = quantile(cty, probs = 0.75),   # cty の 70% 分位点
    n = n()                                # class のデータ数
  )
```

分位点については Level 1 でも紹介しました（geom_boxplot）が、データを小さい順に並べたときに下から 25% のところが 25%分位点、などと呼ばれる数値です。 
n はそのグループに含まれるデータの個数を返します。上の例では 2seater のデータ数が 5 個ということになりますが、本当にそうでしょうか。  

```{r}
mpg %>%
  filter(class == "2seater")
```

確かに 5 個しかないですね。n はこんな風に分類データがあるときデータの個数に偏りがないか、データの個数を使って何か計算したいときとかに使われます。  

なお、自分で作った関数を使うこともできますが、関数については別途触れたいと思います。  

## gather & spread : データを集める、広げる  

gather と spread は互いに逆の操作をする関数で、一方がわかればもう一方もわかると思います。実験データ（特に時間 vs 物理量の形式）の可視化をするときは gather を良く使います。実験データの話題は Level 3 まで置かせてもらいますが、ここでは次の例を使って説明します。  

```{r}
# クルマメーカーごとの燃費を出力する
mpg7 <- mpg %>%
  group_by(manufacturer) %>%
  summarize(
    mean_cty = mean(cty),
    mean_hwy = mean(hwy)
  )
mpg7
```

これは summarize & group_by で作ったデータフレームを再掲したものです。summarize & group_by の項では、geom_bar で mean_cty だけの棒グラフを作成しましたが、mean_hwy も比較したいときはどうすればいいでしょうか。 　

ここで イントロダクションの回を思い出してください。  

<big>
ggplotで利用しやすいフォーマットは、__1行1レコード__ 。
</big>

と実は書いていたのですが、上の mpg7 はそうなっていません。1行2レコードになっています。具体的には、1行目は audi のレコードになっていますが、mean_cty と mean_hwy の2種類のレコードになっています。これだと ggplot で利用しにくいわけです。  

以下、説明をわかりやすくするために mpg7 の初めの5行だけ取り出します。  

```{r}
mpg7 <- mpg7[1:5, ]
mpg7
```

上の方法は紹介し忘れていたのですが、mpg7[1:5,]とすることで1行目から5行目までのすべての列のデータを取り出す、という意味になります。  

話を戻すと、このデータを 1行1レコードにするための関数が gather です。これもまずはやってみましょう。  

```{r}
# データを集める
mpg7 %>%
  gather(mean_cty, mean_hwy, key = mpg, value = val)
```

ん？ちょっとよくわからないと思いますので、処理をわかりやすくするために練習用データに置き換えてやってみましょう。まずは練習用データフレームを作成します。  

```{r}
# 練習用データフレーム
test <- tibble(
  x = c("A", "B", "C", "D", "E"),  # manufacturer に相当
  y1 = 1:5,                        # mean_cty に相当
  y2 = 11:15                       # mean_hwy に相当  
)
test
```

データの構造は mpg7 と同じです。文字列や数値をわかりやすく変えたものです。これに gather をやってみましょう。  

```{r}
test %>%
  gather(y1, y2, key = y, value = val)
```

こうすると、データがどのように操作されたのかわかるのではないでしょうか。gather の前後で見比べてみると次の操作をしていることに気づくと思います。  

* x がそのままコピーされて、行に追加されている。  
* y1, y2 は key で指定した y という変数で整理された。  
* y1, y2 の値は value で指定した val という変数に格納された。  

その結果、1行1レコードになっています。1行目は A というメーカーの y1 という変数の値が val に格納されています。gather の前は、Aというメーカーの y1 という変数と y2 という変数の値がそれぞれの列に格納されていました。  

それでは　mpg7 に戻って可視化までやってみましょう。  

```{r}
# mpg7 を再度作成  
mpg7 <- mpg %>%
  group_by(manufacturer) %>%
  summarize(
    mean_cty = mean(cty),
    mean_hwy = mean(hwy)
  )
mpg7
```

```{r fig.width=10}
mpg7 %>%
  gather(mean_cty, mean_hwy, key = mpg, value = val) %>%
  ggplot(aes(manufacturer,  val, fill = mpg)) +
  geom_bar(stat = "identity", position = "dodge")
```
こうして目的の可視化をすることができました。  

gather の書式についてもう少し詳しく説明します。gather では初めに処理の対象とする変数を指定します。上の例では mean_cty と mean_hwy が gather の対象でした。対象にしなかった manufacturer は test の例で示したとおり、コピーされます。コピーされる数は、gather で指定する変数の数によります。今回は　mean_cty と mean_hwy の 2 つの変数だったので、manufacturerer の audi〜volkswagen までが1回コピーされました。もし mean_*** が 4 つの変数だったら manufacturer は 3 回コピーされます。  

また、gather の対象とする変数名が多いときは、select のときと同じように変数名の冒頭にマイナスをつけると"対象外"にすることができます。上の例でやってみると、

```{r}
mpg7 %>%
  gather(-manufacturer, key = mpg, value = val)   # manufacturer を除外：マイナスをつける
```

gather は Level 3 でもう一度やりますので、そのときにまたやってみましょう。  

spread は gather の逆の処理を行います。gather よりやる頻度は少ないと思います。まずは gather したデータを作成します。   

```{r}
mpg7 <- mpg7 %>% 
  gather(-manufacturer, key = mpg, value = val)  
mpg7
```

```{r}
# spread：データを広げる
mpg7 %>%
  spread(key = mpg, value = val)
```

spread で元に戻りました。key や value の使い方は gather と同じですが、違いは処理の対象とする変数を指定しないことです。  


## arrange：データを並べ替える  

最後に arrange です。これはデータを並べ替えます。値の大きいものランキングを出したいときとかに使うので、位置づけとしては summarize に近いかな、と思います。可視化を行う上では特にやる必要がないのですが、他に紹介する場面がなさそうなのでここで他の関数と一緒に紹介することにしました。  

機能としては、小さい順に並べ替えるか、大きい順に並べ替えるか、の2つです。  

```{r}
mpg %>%
  arrange(cty)    # cty が小さい順にデータフレームを並べ替える  
```

```{r}
mpg %>%
  arrange(desc(cty))    # cty が大きい順にデータフレームを並べ替える  
```

以上で可視化のためのフィルタリングの紹介はひと段落です。他にも inner_join など、Excel で言う lookup 関数的な機能もありますが、そんなに使わないので省略しました。変数の数が多くて、1つのデータフレームでは管理しづらいときに威力を発揮するものですので、興味があったらお声がけください。  

# 練習問題  

## mpg 

1. mpg から日本メーカーのみのデータを取り出し、mpg_jp に格納してください。  
2. mpg_jp について、横軸を manufacturer、縦軸を cty とするボックスプロットを描いてみまししょう（geom_boxplot）。  
3. mpg_jp を用いて、cty, hwy の上位3モデルを特定してください。  
4. mpg_jp を用いて、メーカーごとの cty, hwy の平均値を求め、棒グラフで可視化してください。   
5. 3,4の結果によると honda の燃費がダントツに良いが、それはなぜでしょうか。原因を分析してください。  

## diamonds  

1. diamonds について、新しい変数 size = x * y * z を追加してください。  
2. 横軸を carat、縦軸を size とする散布図を描いてみましょう（geom_point()）。  
3. 2の図から、おかしなデータ（異常値）があることがわかります。異常値を排除したデータを diamonds_rev に格納してください。また diamonds_rev について、2と同様の散布図を描いてみましょう。  



