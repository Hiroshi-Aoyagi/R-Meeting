---
title: "Level2 - データフレームを知る"
output: 
 html_notebook:
   css: font-style.css
---

前回は Geom を知る、ということで可視化に適したデータがある前提で話を進めました。進めるうちに、次のような疑問が湧いた方がいると思います。  

* データをどういうふうに用意すればいいのか  
* データはどんな構造をもっているのか  
* 数値を表すデータだったり文字列だったり、何なのか  

今回は可視化に必要なデータ構造を知ることについて深堀したいと思います。  

今回もライブラリを使いますので、以下のチャンクを実行しておいてください。  

```{r results = 'hide'}
library(tidyverse)
```


# データフレーム  

Rではいろんなデータ形式があります。細かい説明は後ですることにして、まずは以下の点を覚えてください。  

<font size = 5５pt, color = "blue">
可視化で重要な形式は データフレーム dataframe  
</font>

今まで扱ってきたサンプルデータ、mpg や　diamonds はデータフレームです。  

データフレームとは何か、今までも何度も見てきましたがじっくり見てみましょう。  

```{r}
mpg   # Ctrl + Enter で実行
```

右側にも続いているのですが、見づらいと感じる方はコンソール（この画面の左下に Console とあるところをクリック）で View(mpg) と実行してみてください。  

データフレームの特徴を書いてみると:  

1. 列ごとに異なる種類のデータが並んでいる
2. 各列のラベルの下に "chr" とか、"dbl" とかと表示される  
3. 各列にはラベル（変数名）がつけられている(manufacturer, model, ...)  
4. すべての列の行数は等しい  

最後の項目は上の出力の左下にある、"1-10 of 234 rows" からもわかるのですが、データフレームのサイズを確認する方法を2つ紹介します。  

```{r}
# データフレームサイズの確認方法①
str(mpg)
```

前回も紹介した str() の出力を見ると、縦にデータフレームの列の変数が並んでいて "[1:234]" となっているところが各列変数の長さを表しています。mpg の場合は 234 行のデータがあるのがわかります。みんな等しいです。  
（または 出力冒頭の  "tibble [234 × 11]" を見れば 234行11列のデータとわかります）。  

```{r}
# データフレームサイズの確認方法②
dim(mpg)
```

dim() は初登場ですが、dimension の略でデータフレームなどのサイズを知りたいときに使います。これもすぐわかりますが、初めの234が行数、11が列数です。　

ggplot() + geom_*** で可視化するときは、 aes(displ, hwy) などと指定していましたが、使用するデータフレームの列の名前に対応していました。  

逆に言うと、データフレームは上に示した特徴をもつように作成する必要があります。**中でも特に重要なのは 4番で、行数は揃えないといけません。**


# データフレームはベクトルからできている  

続いてデータフレームの作り方、といきたいところなのですが、その前に知っておいた方が良いのがベクトルというデータ形式です。簡単に言うとデータフレームはベクトルからできている、と考えて良いです。具体的には、**データフレームの各列のデータがベクトルです**。例えば、mpg の1列目は次のようにしてベクトルとして取り出せます。  

```{r}
# データフレームからベクトルを取り出す
mpg$manufacturer   # ドル記号 $ をかまして 列名を入力する
```

manufacturer 列はクルマのメーカー名が並んでいましたが、それだけ取り出しました。出力の一番左に [1] とか [8] とか書いてありますが、例えば [204] の行は、「204番目から210番目までのデータだよ」、ということを示しています。なんで最後が210番目と分かるかというと、[204] の下にあるのが[211]だからです。次の行は211番目から始まるので、[204]行の最後は 210番目、という感じです。取り出した順番は、もとのデータフレームのままです。本当か？と思う方は View(mpg)の出力とベクトルの出力を比べてみてください。  

ベクトルの出力はいつもこれと同じように表示されます。他の列も取り出してみましょう。  

```{r}
# データフレームからベクトルを取り出す
mpg$cty
```

cty は各クルマの都市部における燃費（マイル/ガロン）を表していますので、数値が並んでます。メーカー名と違って1データあたり2文字分しか取らないので、1行にたくさんのデータが表示されます。  

というわけで、データフレームがベクトルというものからできているのを分かって頂けたんではないかと思います。  

ところでベクトル（vector）は、高校数学で習ったベクトルと同じ意味です。XY平面上の点Aの位置を表すのに、$\vec{A} = (2,1)$ （注：$記号のあたりにマウスポインタを置いてみてください。htmlファイルでは数式になります）かと表記していたと思います。これは2次元ベクトルと言ってましたよね。3次元ベクトルだと成分が3つになってましたが、より一般的にはn次元ベクトルでデータ列を表現できます。4次元超えると図形的なイメージは人間にはできませんが、定義することはできます。  

今回の場合、各列変数には 234 個のデータがあって、その中の1つの列をベクトルとして取り出しました。そのため、取り出したベクトルは　234 個の成分からなるベクトル（234次元ベクトル）ということになります。  

ベクトルは長いと表示が見づらいことが多いです。そんなときは次の関数が便利です。  

```{r}
# 冒頭だけ表示する
head(mpg$cty, 10)
```

```{r}
# 最後だけ表示する
tail(mpg$cty, 10)
```

headは冒頭から、tailは最後から何番目まで表示するかを指定して出力します。10 を省略するとデフォルトで 6番目まで表示します。  

## データのさらなる取り出し（抽出）

以下、少し脱線です。ベクトルの成分は、[ ]で抽出することができます。  

```{r}
# ベクトルの成分の抽出
mpg$cty[1]
```

mpg$cty の後ろに [1] とつけると、ベクトルの1番目のデータだけ取り出せます。他の番号（234以下の整数）でも試してみてください。  

また、ある範囲のデータを抜き出すこともできます。  

```{r}
# ベクトルの複数成分の抽出
mpg$cty[20:30]
```

20:30 と指定すると、20番目から30番目までを抜き出す、という意味になります。  
または、指定した番号以外の成分を抽出したい、というときもあるでしょう。  

```{r}
# ベクトルの複数成分の抽出：指定した番号以外の成分を抽出する
mpg$cty[-(20:180)]
```

この例では、20番目から180番目以外のデータを抽出してます。つまり1〜19番目と、181〜234番目までが抽出されています。マイナス - をつけることで可能ですが、複数指定する場合は -() とします。  

連続していなければだめなのか？と思った方、不連続でもいけます。少し手間がかかりますが...  

```{r}
# ベクトルの複数成分の抽出2
mpg$cty[c(2, 20, 42, 67, 89, 95)]
```

c() で抜き出したい番号をカンマ区切りで指定して、[ ] の中に入れてあげます。実行例では、2番目、20番目、42番目、67番目、89番目、95番目 だけを抜き出しました。c() についてはすぐ後に説明がありますので少し待ってください。  

なんか条件をつけて抜き出したいってこともあるだろう、という方、それもできます。例えばメーカーがアウディのデータだけとか、燃費が 20以下のデータだけとか...  

```{r}
# 条件によってデータを抽出する
mpg$manufacturer[mpg$manufacturer == "audi"]
```

イコールが二重になっているのは間違いではありません。たいていのプログラミング言語では、二重のイコール "==" は「左辺と右辺が等しいか？」を判定する演算子です。上の例では、manufacturer が audi に等しいかを判定していて、それが正しい（"真"（TRUE）、といいます）データだけを抽出する意味になっています（正しくないときは、"偽"(FALSE)といいます）。  

ちなみに "audi"ではないメーカーを探すときは以下のようになります。  

```{r}
# 条件によってデータを抽出する
mpg$manufacturer[mpg$manufacturer != "audi"]
```

!= は、「イコールでない」を意味するこれまた演算子です。"audi"以外が出力されました。  

```{r}
# 条件によってデータを抽出する2
mpg$cty[mpg$cty < 20]
```

実際の応用では、例えば「cty が 20以上のクルマメーカーは？」というように、「変数Aがある条件を満たすときの変数Bのデータ」 を抽出したいことが多いですよね。そういうときは...  

```{r}
# 条件によってデータを抽出する2
mpg$manufacturer[mpg$cty > 20]
```

あくまでサンプルデータセットの中ではありますが、これだけでも「日本車は比較的燃費が良い」、という分析ができそうですね。  

脱線終わり。  


# データの型とクラス  

それではデータフレームの作成にいきましょう、とはいかないのです。データフレームはベクトルからできている、と説明したので、ベクトルの作成方法から説明します。遠回りのような気がしますが、ベクトルの作成方法がわかればデータフレームの作成は簡単です。  

前項ではできあいのデータフレームからベクトルを抽出する方法を説明しましたが、これはあくまでデータフレームがどういうものかイメージしてもらうため。本来は自分でベクトルからデータフレームを作成したり、後日説明しますがデータファイルから読み込んでデータフレームを作成したりします。順序が逆になりますので、**ここでちょっと思考を切り替えてください**。  

## データの型  

前置きが長くなりましたが、ベクトルを作成するにあたって知っておかなければならないのがデータの型(type)です。R（と他の言語）の代表的な型は以下の6つがあります。  

* 整数型: int ... integer から来ている。名前の通り整数。    
* 実数型: dbl ... double から来ている。倍精度浮動小数点型（要は小数点以下も含めた数値のこと）  
* 文字型: chr ... character から来ている。名前の通り文字や文字列。  
* 論理型: logical ... TRUE(1) か FALSE（0) のみをもつ。  
* 複素数型: complex ... そのまんま。実部と虚部をもつ。  
* ファクタ型: fct ... factor から来ている。int または character の見た目だが、順位をもっているもの。  

なんか見覚えありますよね。 str() とか、mpg を実行したときに出てきてました（見覚えない方は冒頭の方の実行例を見直してみてください）。あれはデータの型でした。  

自分で作成するベクトルのうち 90% くらいは int, dbl, chr ですのでこれらをメインに説明します。ちなみに複素数型なんかいつ使うんだ？と思うかもしれませんが、FFT（高速フーリエ変換）して時間データを周波数データに変換すると出てくる、という意味では割と目にするかもしれません（FFTは fft(x) （x は int または dbl のベクトル）で実行できる、とだけ紹介してておきます）。  

### ベクトルの作成方法とデータ型の確認方法

さっそくやってみましょう。まずはもっとも簡単な int から。  

```{r}
# 連続の整数型ベクトルを作成する
x <- 1:10  # Ctrl + Shift + Enter で実行
x
```

1:10とか、コロンで挟むと刻みが1の整数ベクトルを作成してくれます。<- は「右側のデータを左のパラメータに代入する」という意味の演算子です（= でも同じ意味なのですが、Rでは <-　を慣習的に使う人が多いようです）。したがって、x <- 1:10 は、x に 1:10 というベクトルを代入する、という意味です。  

データの型は typeof() で確認できます。これは整数型だけでなく、どんな型でも確認できます。    

```{r}
# データの型を確認する
typeof(x)
```

```{r}
# 連続の整数型ベクトルを作成する
x <- 10:1
x
```

指定する数値は逆でもOKです。

```{r}
# 連続の整数型ベクトルを作成する
x <- -10:10
x
```

マイナス値の指定もいけます。  

連続値ではない方法で、これも簡単な規則性のあるやり方から。  

```{r}
# 整数型ベクトルを作成する - 規則性あり1
x <- seq(from = 0, to = 10, by = 2)
x
```
 seq() は sequential（シーケンシャル）から来てます。引数の意味はなんとなくわかるんではないかと思います。from = , to = , by = の部分は省略できます（seq(0, 10, 2)で良い）。   
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(2, times = 10)
x
```

rep は　replicate（繰り返し）から来ていて、数値を指定回数繰り返したベクトルを出力します。  
seq と同様に、times = は省略できます。  
 
rep は次のような使い方も可能です。
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(1:5, 3)
x
```
 この場合、1:5 を3回繰り返します。もうひとつあります。  
 
```{r}
# 整数型ベクトルを作成する - 規則性あり2
x <- rep(1:5, each = 3)
x
```
第2引数を each = とすることでそれぞれを 3 回ずつ繰り返し、というパターンになります。  

seq や rep は一見すると、「そんな単純な整数列作って何になるんだ」と思いますが、これが意外に結構使います。今は使わなくてもそのうち使うはずなので、こんなんあるんだ、くらいで覚えておくと良いです。  
 
さらに一般的な整数数列を作りたいときは、c() を使います。  

```{r}
# 整数型ベクトルを作成する - 規則性なし
x <- c(-3, 5, 1000, -213, 77, 84)
x
```

c() の c は combine（組み合わせ）から来ています。ベクトルをつなげる機能をもっています、というのが正しい説明なのですが、少し補足。Rでは1つの変数もベクトルです。例えば、  

```{r}
x <- 5
x
```

出力に注目してください。x には 5 という数値1つだけが代入されるのですが、出力には [1] が左側についています。つまり、x は長さ1のベクトルです。というわけで、c(-3, 5, 1000, -213, 77, 84) は、長さ1のベクトル -3, 5, 1000, -213, 77, 84 を1つのベクトルにつなげて長さ5のベクトルを作成する、という意味です。補足終わり。  

このベクトルも、rep と組み合わせられます。  

```{r}
# 整数型ベクトルを作成する - 規則性なしを繰り返す
rep(x, 5)
```

-------------------------------------------------------------------------------------------

続いて dbl 型ですが、基本的な作り方は int 型と共通です。 

```{r}
# dbl型
x <- seq(0, 10, length.out = 5)
x
```

seq の第2引数を length.out にして、一定間隔で小数点以下を含む実数を作成しました。length.out は int でも使えますが、ちょうど割り切れないと dbl 型になります。  

```{r}
typeof(x)
```

気づいた方もいると思いますが、ベクトルはひとつの型しかもてません。int 型と dbl 型を混在できないのは上の例からわかると思います。 0.0 や 5.0 は 0 や 5 と等しく int 型でも良いのですが、他の数値が　dbl 型なので、そっちに合わせられています。というわけで、データ型には階層構造（上位、下位）があるのですがあんまり気にしなくても良いので先にいきます。  

rep() や c()　の使い方も int 型と同じです。  

```{r}
rep(x, 3)
```

-------------------------------------------------------------------------------------------------

chr 型も基本は同じですが、seq は使えません。文字型の場合は文字列を ダブルクォーテーションまたはシングルクォーテーションで囲む必要があります。  

```{r}
# chr 型
x <- c("apple", "orange", "banana")
x
```

```{r}
typeof(x)
```

rep() は chr 型でも使えます。 

```{r}
rep(x, 3)
```

文字列は文章みたいに長くても良いです。tidyverse にある例を見てみましょう。  

```{r}
head(sentences)
```

```{r}
typeof(sentences)
```

ちなみに日本語可です。  

```{r}
x <- c("リンゴ", "オレンジ", "バナナ")
x
```

文字列を操作する関数もたくさんあって、可視化のときに便利なことがあるのですが、ここではベクトルの作成方法が主目的なので省略します。可視化の際に機会があれば触れたいと思います。  


## クラス  

### データフレームの作成と型、クラスの関係    

さて、ようやくデータフレームの作成です。まずは作成してみましょう。ベクトルの作成も含めてやってみます。  

```{r}
df <- tibble(
  x = 1:5,
  y = seq(-2, 5, length.out = 5),
  z = c("SS400", "S45C", "ADC12", "C1100", "PP")
)
df
```

tibble() というのがデータフレームを作成する関数で、内容が x, y, z という変数で、それぞれ長さ 5 で統一されたベクトルになっていることに注意してください。  

これだけです。作成したデータフレーム df に typeof() を適用してみると...

```{r}
typeof(df)
```

データフレームにも型があり、リスト、という名前がついています。  

ちょっとわかりづらいのですが、Rではデータ形式の分類としてデータ型（type）の他にクラス（class）があります。 

```{r}
class(df)
```

クラスを確認する関数はそのまま class()。これを実行すると data.frame と出てきました。つまり、データフレームの方はリスト、クラスはデータフレーム、ということになります。で、これは私見ですが、概念としては型の方が上位と考えた方が整理しやすいので、リストの中のデータフレーム、と理解すると良いと思います。  

その上でもう一度 class の出力を見ると、"data.frame" のほかに "tbl_df", "tbl" とあります。これらもデータフレームとほぼ同じものと考えて差し支えありませんが、若干違います。data.frame は base R にもともとあるクラスなのですが、どうも古くなってしまったようで使い勝手が悪い場合があるようです。そこでそれを改良したのが tbl で、これは tibble の略です。データフレームの作成で tibble() を使ったのはこれです。したがって、データフレームは data.frame() でも作れますが、今回の勉強会ではそうする必要がないので使いません。  

（つづく）  


